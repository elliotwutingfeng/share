// Copyright 2019, Shulhan <ms@kilabit.info>. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package memfs

import (
	"fmt"
	"text/template"
)

const (
	templateNameHeader       = "HEADER"
	templateNameGenerateNode = "GENERATE_NODE"
	templateNamePathFuncs    = "PATH_FUNCS"
)

//
// generateTemplate generate the .go source template.
//
// The .go source template contains three sections: HEADER, GENERATE_NODE,
// and PATH_FUNCS.
//
// The HEADER section accept single parameter: the package name, as a string.
//
// The GENERATE_NODE section accept single parameter: the *Node, which then
// converted into function that return the *Node itself,
//
//	function generate{{ Node.Path}} (node *memfs.Node) {
//		node = &memfs.Node{
//			...
//		}
//	}
//
// Then Node itself then registered in memfs global variable
// "GeneratedPathNode".
//
// The PATH_FUNCS section generate the init() function that map each
// Node's Path with the function generated from GENERATE_NODE.
//
func generateTemplate() (tmpl *template.Template, err error) {
	var textTemplate = `{{ define "HEADER" -}}
// Code generated by github.com/shuLhan/share/lib/memfs DO NOT EDIT.

package {{.}}

import (
	"github.com/shuLhan/share/lib/memfs"
)
{{end}}
{{define "GENERATE_NODE"}}
	{{- $varname := .VarName}}
func {{ .Node.GenFuncName}}() *memfs.Node {
	node := &memfs.Node{
		SysPath:         "{{.Node.SysPath}}",
		Path:            "{{.Node.Path}}",
		ContentType:     "{{.Node.ContentType}}",
		ContentEncoding: "{{.Node.ContentEncoding}}",
{{- if .Node.V }}
		V:               []byte("{{range $x, $c := .Node.V}}{{ printf "\\x%02X" $c }}{{end}}"),
{{- end }}
	}
	node.SetMode({{printf "%d" .Node.Mode}})
	node.SetName("{{.Node.Name}}")
	node.SetSize({{.Node.Size}})
	{{- range $x, $child := .Node.Childs}}
	node.AddChild(_getNode({{$varname}}, "{{.Path}}", {{$child.GenFuncName}}))
	{{- end}}
	return node
}
{{end}}
{{define "PATH_FUNCS"}}
//
// _getNode is internal function to minimize duplicate node created on
// Node.AddChild() and on generatedPathNode.Set().
//
func _getNode(pn *memfs.PathNode, path string, fn func() *memfs.Node) *memfs.Node {
	node := pn.Get(path)
	if node != nil {
		return node
	}
	return fn()
}

func init() {
	{{- $varname := .VarName}}
	{{$varname}} = memfs.NewPathNode()
{{- range $path, $node := .Nodes}}
	{{$varname}}.Set("{{$path}}",
		_getNode({{$varname}}, "{{$path}}", {{$node.GenFuncName}}))
{{- end}}
}
{{end}}
`
	tmpl, err = template.New("memfs").Parse(textTemplate)
	if err != nil {
		return nil, fmt.Errorf("generateTemplate: %w", err)
	}

	return tmpl, nil
}
