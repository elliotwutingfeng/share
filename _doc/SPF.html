<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta name="theme-color" content="#375EAB" />

		<title>Sender Policy Framework (SPF) for Authorizing Use of Domains in Email, Version 1</title>

		<style>
		
body {
	margin: 0;
	font-family: Arial, sans-serif;
	background-color: #fff;
	line-height: 1.3;
	text-align: center;
	color: #222;
}
pre,
code {
	font-family: Menlo, monospace;
	font-size: 0.875rem;
}
pre {
	line-height: 1.4;
	overflow-x: auto;
	background: #efefef;
	padding: 0.625rem;
	border-radius: 0.3125rem;
}
a {
	color: #007d9c;
	text-decoration: none;
}
a:hover {
	text-decoration: underline;
}

p,
li {
	max-width: 50rem;
	word-wrap: break-word;
}
li p {
	margin: 2px;
}
p,
pre,
ul,
ol {
	margin: 1.25rem;
}

h1,
h2,
h3,
h4 {
	margin: 1.25rem 0 1.25rem;
	padding: 0;
	color: #007d9c;
	font-weight: bold;
}
h1 {
	font-size: 1.75rem;
	line-height: 1;
}
h1 .text-muted {
	color: #777;
}
h2 {
	clear: right;
	font-size: 1.25rem;
	background: #e0ebf5;
	padding: 0.5rem;
	line-height: 1.25;
	font-weight: normal;
	overflow: auto;
	overflow-wrap: break-word;
}
h2 a {
	font-weight: bold;
}
h3 {
	font-size: 1.25rem;
	line-height: 1.25;
	overflow: auto;
	overflow-wrap: break-word;
}
h3,
h4 {
	margin: 1.25rem 0.3125rem;
}
h4 {
	font-size: 1rem;
}

h2 > span,
h3 > span {
	float: right;
	margin: 0 25px 0 0;
	font-weight: normal;
	color: #5279c7;
}

dl {
	margin: 1.25rem;
}
dd {
	margin: 0 0 0 1.25rem;
}
dl,
dd {
	font-size: 0.875rem;
}

/**
 * Custom classes for pages
 */

.topbar {
	background: #e0ebf5;
	height: 4rem;
	overflow: hidden;
}

.topbar .top-heading,
.topbar .menu {
	padding: 1.313rem 0;
	font-size: 1.25rem;
	font-weight: normal;
}
.topbar .top-heading {
	float: left;
}
.topbar .top-heading a {
	color: #222;
	text-decoration: none;
}

.top-heading .header-logo {
	height: 2rem;
	width: 5.125rem;
}

.topbar .menu {
	float: right;
}
.topbar .menu a {
	margin: 0.625rem 0.125rem;
	padding: 0.625rem;
	color: white;
	background: #007d9c;
	border: 0.0625rem solid #007d9c;
	border-radius: 5px;
}
.topbar .menu form {
	display: inline-block;
}

.page {
	width: 100%;
}

.page > .container,
.topbar > .container,
.footer > .container {
	margin-left: auto;
	margin-right: auto;
	padding: 0 1.25rem;
	max-width: 59.38rem;
}

.page > .container {
	text-align: left;
}

.container .meta {
	font-style: italic;
	margin: 1.25rem;
}

.footer {
	text-align: center;
	color: #666;
	font-size: 0.875rem;
	margin: 2.5rem 0;
}

/** Custom classes for asciidoc */
#toctitle {
	display: none;
}
#toc li {
	list-style: none;
}
#toc ul .sectlevel1 {
	padding: 0px;
	margin: 4px;
}
#toc ul .sectlevel2 {
	margin: 4px;
}

@media screen and (max-width: 992px) {
	#toc {
		all: unset;
	}
}

		</style>
	</head>
	<body>
		<div class="topbar">
			<div class="container">
				<div class="top-heading">
					<a href="/">ciigo</a>
				</div>
				<div class="menu">
					<form class="item" action="/_internal/search">
						<input type="text" name="q" placeholder="Search" />
					</form>
				</div>
			</div>
		</div>

		<div class="page">
			<div class="container">
				
<div id="header">
<h1>Sender Policy Framework (SPF) for Authorizing Use of Domains in Email, Version 1</h1>
<div class="details">
<span id="author" class="author">Shulhan</span><br>
<span id="email" class="email"><a href="mailto:ms@kilabit.info">ms@kilabit.info</a></span><br>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">1. Introduction</a></li>
<li><a href="#_operational_overview">2. Operational Overview</a>
<ul class="sectlevel2">
<li><a href="#_publishing_authorization">2.1. Publishing Authorization</a></li>
<li><a href="#_checking_authorization">2.2. Checking Authorization</a></li>
<li><a href="#_the_helo_identity">2.3. The "HELO" Identity</a></li>
<li><a href="#_the_mail_from_identity">2.4. The "MAIL FROM" Identity</a></li>
<li><a href="#_location_of_checks">2.5. Location of Checks</a></li>
<li><a href="#_results_of_evaluation">2.6. Results of Evaluation</a></li>
</ul>
</li>
<li><a href="#_spf_records">3. SPF Records</a>
<ul class="sectlevel2">
<li><a href="#_dns_resource_record">3.1. DNS Resource Record</a></li>
<li><a href="#_multiple_dns_records">3.2. Multiple DNS Records</a></li>
<li><a href="#_multiple_strings_in_a_single_dns_record">3.3. Multiple Strings in a Single DNS Record</a></li>
<li><a href="#_record_size">3.4. Record Size</a></li>
<li><a href="#_wildcard_records">3.5. Wildcard Records</a></li>
</ul>
</li>
<li><a href="#_the_check_host_function">4. The check_host() Function</a>
<ul class="sectlevel2">
<li><a href="#_arguments">4.1. Arguments</a></li>
<li><a href="#_results">4.2. Results</a></li>
<li><a href="#_initial_processing">4.3. Initial Processing</a></li>
<li><a href="#_record_lookup">4.4. Record Lookup</a></li>
<li><a href="#_selecting_records">4.5. Selecting Records</a></li>
<li><a href="#_record_evaluation">4.6. Record Evaluation</a></li>
<li><a href="#_default_result">4.7. Default Result</a></li>
<li><a href="#_domain_specification">4.8. Domain Specification</a></li>
</ul>
</li>
<li><a href="#_mechanism_definitions">5. Mechanism Definitions</a>
<ul class="sectlevel2">
<li><a href="#_all">5.1. "all"</a></li>
<li><a href="#_include">5.2. "include"</a></li>
<li><a href="#_a">5.3. "a"</a></li>
<li><a href="#_mx">5.4. "mx"</a></li>
<li><a href="#_mechanism_ptr">5.5. "ptr" (do not use)</a></li>
<li><a href="#_ip4_and_ip6">5.6. "ip4" and "ip6"</a></li>
<li><a href="#_exist">5.7. "exist"</a></li>
</ul>
</li>
<li><a href="#_modifier_definitions">6. Modifier Definitions</a>
<ul class="sectlevel2">
<li><a href="#_redirect_redirected_query">6.1. redirect: Redirected Query</a></li>
<li><a href="#_exp_explanation">6.2. exp: Explanation</a></li>
</ul>
</li>
<li><a href="#_macros">7. Macros</a>
<ul class="sectlevel2">
<li><a href="#_formal_specification">7.1. Formal Specification</a></li>
<li><a href="#_macro_definitions">7.2. Macro Definitions</a></li>
<li><a href="#_macro_processing_details">7.3. Macro Processing Details</a></li>
<li><a href="#_expansion_examples">7.4. Expansion Examples</a></li>
</ul>
</li>
<li><a href="#_result_handling">8. Result Handling</a>
<ul class="sectlevel2">
<li><a href="#_none">8.1. None</a></li>
<li><a href="#_neutral">8.2. Neutral</a></li>
<li><a href="#_pass">8.3. Pass</a></li>
<li><a href="#_fail">8.4. Fail</a></li>
<li><a href="#_softfail">8.5. Softfail</a></li>
<li><a href="#_temperror">8.6. Temperror</a></li>
<li><a href="#_permerror">8.7. Permerror</a></li>
</ul>
</li>
<li><a href="#_recording_the_result">9. Recording the Result</a>
<ul class="sectlevel2">
<li><a href="#_the_received_spf_header_field">9.1. The Received-SPF Header Field</a></li>
<li><a href="#_spf_results_in_the_authentication_results_header_field">9.2. SPF Results in the Authentication-Results Header Field</a></li>
</ul>
</li>
<li><a href="#_effects_on_infrastructure">10. Effects on Infrastructure</a>
<ul class="sectlevel2">
<li><a href="#_sending_domains">10.1. Sending Domains</a></li>
<li><a href="#_receivers">10.2. Receivers</a></li>
<li><a href="#_mediator">10.3. Mediator</a></li>
</ul>
</li>
<li><a href="#_security_considerations">11. Security Considerations</a>
<ul class="sectlevel2">
<li><a href="#_processing_limits">11.1. Processing Limits</a></li>
<li><a href="#_spf_authorized_email_may_contain_other_false_identities">11.2. SPF-Authorized Email May Contain Other False Identities</a></li>
<li><a href="#_spoofed_dns_and_ip_data">11.3. Spoofed DNS and IP Data</a></li>
<li><a href="#_cross_user_forgery">11.4. Cross-User Forgery</a></li>
<li><a href="#_untrusted_information_sources">11.5. Untrusted Information Sources</a></li>
<li><a href="#_privacy_exposure">11.6. Privacy Exposure</a></li>
<li><a href="#_delivering_mail_producing_a_fail_result">11.7. Delivering Mail Producing a "Fail" Result</a></li>
</ul>
</li>
</ul>

</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This document provide note and summary of
<a href="https://tools.ietf.org/html/rfc7208">RFC 7208</a>,
Sender Policy Framework (SPF) for Authorizing Use of Domains in Email, Version
1.
The content of this document are merged with errata that are reported before
2019-04-04.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction"><a class="anchor" href="#_introduction"></a>1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This document defines a protocol by which ADministrative Management Domains
(ADMD) can authorize hosts to use their domain names in the "MAIL FROM" or
"HELO" identities.
Compliant ADMDs publish Sender Policy Framework (SPF) records in the DNS
specifying which hosts are permitted to use their names, and compliant mail
receivers use the published SPF records to test the authorization of sending
Mail Transfer Agents (MTAs) using a given "HELO" or "MAIL FROM" identity
during a mail transaction.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_operational_overview"><a class="anchor" href="#_operational_overview"></a>2. Operational Overview</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_publishing_authorization"><a class="anchor" href="#_publishing_authorization"></a>2.1. Publishing Authorization</h3>
<div class="paragraph">
<p>An SPF-compliant domain publishes valid SPF records to authorize the use of
the relevant domain names in the "HELO" and "MAIL FROM" identities by the MTAs
specified therein.</p>
</div>
<div class="paragraph">
<p>SPF results can be used to make both positive (source is authorized)
and negative (source is not authorized) determinations.
If ADMDs choose to publish SPF records and want to support receivers making
negative authorization determinations, it is necessary for them to publish
records that end in "-all", or redirect to other records that do;
otherwise, no definitive determination of authorization can be made.</p>
</div>
<div class="paragraph">
<p>When changing SPF records, care has to be taken to ensure that there is a
transition period so that the old policy remains valid until all legitimate
email can reasonably expect to have been checked.</p>
</div>
</div>
<div class="sect2">
<h3 id="_checking_authorization"><a class="anchor" href="#_checking_authorization"></a>2.2. Checking Authorization</h3>
<div class="paragraph">
<p>A mail receiver can perform a set of SPF checks for each mail message it
receives.
Typically, such checks are done by a receiving MTA, but can be performed
elsewhere in the mail processing chain so long as the required information is
available and reliable.</p>
</div>
<div class="paragraph">
<p>Without explicit approval of the publishing ADMD, checking other identities
against SPF version 1 records is NOT RECOMMENDED because there are cases that
are known to give incorrect results.
For example, almost all mailing lists rewrite the "MAIL FROM" identity, but
some do not change any other identities in the message.
Documents that define other identities will have to define the method for
explicit approval.</p>
</div>
<div class="paragraph">
<p>To make the test, the mail receiver MUST evaluate the check_host() function.</p>
</div>
<div class="paragraph">
<p>Although invalid, malformed, or non-existent domains cause SPF checks to
return "none" because no SPF record can be found, it has long been the policy
of many MTAs to reject email from such domains, especially in the case of
invalid "MAIL FROM".
Rejecting email will prevent one method of circumventing of SPF records.</p>
</div>
<div class="paragraph">
<p>Implementations have to take care to correctly extract the &lt;domain&gt; from the
data given with the SMTP MAIL FROM command as many MTAs will still accept such
things as source routes, the %-hack (see [RFC1123]), and bang paths (see
[RFC1983]).
These archaic features have been maliciously used to bypass security systems.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_helo_identity"><a class="anchor" href="#_the_helo_identity"></a>2.3. The "HELO" Identity</h3>
<div class="paragraph">
<p>It is RECOMMENDED that SPF verifiers not only check the "MAIL FROM" identity
but also separately check the "HELO" identity by applying the check_host()
function (Section 4) to the "HELO" identity as the &lt;sender&gt;.
If a conclusive determination about the message can be made based on a check
of "HELO", then the use of DNS resources to process the typically more complex
"MAIL FROM" can be avoided.
Additionally, since SPF records published for "HELO" identities refer to a
single host, when available, they are a very reliable source of host
authorization status.
Checking "HELO" before "MAIL FROM" is the RECOMMENDED sequence if both are
checked.</p>
</div>
<div class="paragraph">
<p>This SPF check can only be performed when the "HELO" string is a valid,
multi-label domain name.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_mail_from_identity"><a class="anchor" href="#_the_mail_from_identity"></a>2.4. The "MAIL FROM" Identity</h3>
<div class="paragraph">
<p>SPF verifiers MUST check the "MAIL FROM" identity if a "HELO" check either has
not been performed or has not reached a definitive policy result by applying
the check_host() function to the "MAIL FROM" identity as the &lt;sender&gt;.</p>
</div>
<div class="paragraph">
<p>If the reverse-path is null, this document defines the "MAIL FROM" identity to
be the mailbox composed of the local-part "postmaster" and the "HELO" identity
(which might or might not have been checked separately before).</p>
</div>
</div>
<div class="sect2">
<h3 id="_location_of_checks"><a class="anchor" href="#_location_of_checks"></a>2.5. Location of Checks</h3>
<div class="paragraph">
<p>The authorization check is performed during the SMTP transaction at the time
of the MAIL command, and uses the MAIL FROM value and the client IP address.
Performing the check at later times or with other input can cause problems
such as the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It might be difficult to accurately extract the required information from
potentially deceptive headers.</p>
</li>
<li>
<p>Legitimate email might fail the authorization check because the sender&#8217;s
policy has since changed.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_results_of_evaluation"><a class="anchor" href="#_results_of_evaluation"></a>2.6. Results of Evaluation</h3>
<div class="paragraph">
<p>Moved to &lt;&lt;#_results,section 4.2&gt;&gt;.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spf_records"><a class="anchor" href="#_spf_records"></a>3. SPF Records</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The SPF record is expressed as a single string of text found in the RDATA of a
single DNS TXT resource record; multiple SPF records are not permitted for the
same owner name.</p>
</div>
<div class="sect2">
<h3 id="_dns_resource_record"><a class="anchor" href="#_dns_resource_record"></a>3.1. DNS Resource Record</h3>
<div class="paragraph">
<p>SPF records MUST be published as a DNS TXT (type 16) Resource Record (RR)
only.
The character content of the record is encoded as [US-ASCII].</p>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_dns_records"><a class="anchor" href="#_multiple_dns_records"></a>3.2. Multiple DNS Records</h3>
<div class="paragraph">
<p>A domain name MUST NOT have multiple records that would cause an authorization
check to select more than one record.</p>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_strings_in_a_single_dns_record"><a class="anchor" href="#_multiple_strings_in_a_single_dns_record"></a>3.3. Multiple Strings in a Single DNS Record</h3>
<div class="paragraph">
<p>If a published record contains multiple character-strings, then the record
MUST be treated as if those strings are concatenated together without adding
spaces.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>IN TXT "v=spf1 .... first" "second string..."</pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>IN TXT "v=spf1 .... firstsecond string..."</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_record_size"><a class="anchor" href="#_record_size"></a>3.4. Record Size</h3>
<div class="paragraph">
<p>If the size of the DNS message, the combined length of the DNS name and the
text of all the records of a given type is under 450 octets, then DNS answers
ought to fit in UDP packets.
Records that are too long to fit in a single UDP packet could be silently
ignored by SPF verifiers due to firewall and other issues that interfere with
the operation of DNS over TCP or using EDNS0.</p>
</div>
<div class="paragraph">
<p>Note that when computing the sizes for replies to queries of the TXT format,
one has to take into account any other TXT records published at the domain
name.
Similarly, the sizes for replies to all queries related to SPF have to be
evaluated to fit in a single 512-octet UDP packet.</p>
</div>
</div>
<div class="sect2">
<h3 id="_wildcard_records"><a class="anchor" href="#_wildcard_records"></a>3.5. Wildcard Records</h3>
<div class="paragraph">
<p>Use of wildcard records for publishing is discouraged, and care has to be
taken if they are used.</p>
</div>
<div class="paragraph">
<p>SPF records have to be listed twice for every name within the zone:
once for the name, and once with a wildcard to cover the tree under the name,
in order to cover all domains in use in outgoing mail.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_check_host_function"><a class="anchor" href="#_the_check_host_function"></a>4. The check_host() Function</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>check_host()</code> function fetches SPF records, parses them, and
evaluates them to determine whether a particular host is or is not
permitted to send mail with a given identity.
Receiving ADMDs that perform this check MUST correctly evaluate the
<code>check_host()</code> function as described here.</p>
</div>
<div class="sect2">
<h3 id="_arguments"><a class="anchor" href="#_arguments"></a>4.1. Arguments</h3>
<div class="paragraph">
<p>The <code>check_host()</code> function takes these arguments:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&lt;ip&gt;</code>: the IP address of the SMTP client that is emitting the mail, either
IPv4 or IPv6.</p>
</li>
<li>
<p><code>&lt;domain&gt;</code>: the domain that provides the sought-after authorization
information; initially, the domain portion of the "MAIL FROM" or "HELO"
identity.</p>
</li>
<li>
<p><code>&lt;sender&gt;</code>: the "MAIL FROM" or "HELO" identity.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_results"><a class="anchor" href="#_results"></a>4.2. Results</h3>
<div class="paragraph">
<p>This section enumerates and briefly defines the possible outputs of
<code>check_host()</code> function.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>"none": means either,</p>
<div class="ulist">
<ul>
<li>
<p>no syntactically valid DNS domain name was extracted from the SMTP session
that could be used as the one to be authorized, or</p>
</li>
<li>
<p>no SPF records were retrieved from the DNS.</p>
</li>
</ul>
</div>
</li>
<li>
<p>"neutral": means the ADMD has explicitly stated that it is not asserting
whether the IP address is authorized.</p>
</li>
<li>
<p>"pass": an explicit statement that the client is authorized to inject mail
with the given identity.</p>
</li>
<li>
<p>"fail": an explicit statement that the client is not authorized to use the
domain in the given identity.</p>
</li>
<li>
<p>"softfail": a weak statement by the publishing ADMD that the host is
probably not authorized.
It has not published a stronger, more definitive policy that results in a
"fail".</p>
</li>
<li>
<p>"temperror":  the SPF verifier encountered a transient (generally DNS)
error while performing the check.
A later retry may succeed without further DNS operator action.</p>
</li>
<li>
<p>"permerror":  the domain&#8217;s published records could not be correctly
interpreted.
This signals an error condition that definitely requires DNS operator
intervention to be resolved.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_initial_processing"><a class="anchor" href="#_initial_processing"></a>4.3. Initial Processing</h3>
<div class="paragraph">
<p>If the &lt;domain&gt; is malformed (e.g., label longer than 63 characters,
zero-length label not at the end, etc.) or is not a multi-label domain name,
or if the DNS lookup returns "Name Error" (RCODE 3, also known as "NXDOMAIN"
[RFC2308]), check_host() immediately returns the result "none".</p>
</div>
<div class="paragraph">
<p>If the &lt;sender&gt; has no local-part, substitute the string "postmaster" for the
local-part.</p>
</div>
</div>
<div class="sect2">
<h3 id="_record_lookup"><a class="anchor" href="#_record_lookup"></a>4.4. Record Lookup</h3>
<div class="paragraph">
<p>A DNS query needs to be made for the &lt;domain&gt; name, querying for type TXT
only.</p>
</div>
<div class="paragraph">
<p>If the DNS lookup returns a server failure (RCODE 2) or some other error
(RCODE other than 0 or 3), or if the lookup times out, then <code>check_host()</code>
terminates immediately with the result "temperror".</p>
</div>
</div>
<div class="sect2">
<h3 id="_selecting_records"><a class="anchor" href="#_selecting_records"></a>4.5. Selecting Records</h3>
<div class="paragraph">
<p>Records begin with a version section:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>record   = version terms *SP
version  = "v=spf1"</pre>
</div>
</div>
<div class="paragraph">
<p>If the resultant record set includes no records, <code>check_host()</code> produces the
"none" result.
If the resultant record set includes more than one record, <code>check_host()</code>
produces the "permerror" result.</p>
</div>
</div>
<div class="sect2">
<h3 id="_record_evaluation"><a class="anchor" href="#_record_evaluation"></a>4.6. Record Evaluation</h3>
<div class="paragraph">
<p>The <code>check_host()</code> function parses and interprets the SPF record to find a
result for the current test.
if there are any syntax errors anywhere in the record, <code>check_host()</code> returns
immediately with the result "permerror", without further interpretation or
evaluation.</p>
</div>
<div class="sect3">
<h4 id="_term_evaluation"><a class="anchor" href="#_term_evaluation"></a>4.6.1. Term Evaluation</h4>
<div class="paragraph">
<p>There are two types of terms: mechanisms and modifiers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>terms            = *( 1*SP ( directive / modifier ) )

directive        = [ qualifier ] mechanism
qualifier        = "+" / "-" / "?" / "~"
mechanism        = ( all / include
                   / a / mx / ptr / ip4 / ip6 / exists )
modifier         = redirect / explanation / unknown-modifier
unknown-modifier = name "=" macro-string
                 ; where name is not any known modifier

name             = ALPHA *( ALPHA / DIGIT / "-" / "_" / "." )</pre>
</div>
</div>
<div class="paragraph">
<p>Most mechanisms allow a ":" or "/" character after the name.</p>
</div>
<div class="paragraph">
<p>Modifiers always contain an equals ('=') character immediately after the name,
and before any ":" or "/" characters that might be part of the macro-string.</p>
</div>
<div class="paragraph">
<p>Terms that do not contain any of "=", ":", or "/" are mechanisms.</p>
</div>
<div class="paragraph">
<p>Mechanism and modifier names are case-insensitive.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mechanisms"><a class="anchor" href="#_mechanisms"></a>4.6.2. Mechanisms</h4>
<div class="paragraph">
<p>Each mechanism is considered in turn from left to right.
If there are no more mechanisms, the result is the default result.</p>
</div>
<div class="paragraph">
<p>When a mechanism is evaluated, one of three things can happen: it can match,
not match, or return an exception.</p>
</div>
<div class="paragraph">
<p>If it matches, processing ends and the qualifier value is returned as the
result of that record.
If it does not match, processing continues with the next mechanism.
If it returns an exception, mechanism processing ends and the exception value
is returned.</p>
</div>
<div class="paragraph">
<p>The possible qualifiers, and the results they cause <code>check_host()</code> to return,
are as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>"+" pass
"-" fail
"~" softfail
"?" neutral</pre>
</div>
</div>
<div class="paragraph">
<p>The qualifier is optional and defaults to "+".</p>
</div>
<div class="paragraph">
<p>When a mechanism matches and the qualifier is "-", then a "fail" result is
returned.</p>
</div>
</div>
<div class="sect3">
<h4 id="_modifiers"><a class="anchor" href="#_modifiers"></a>4.6.3. Modifiers</h4>
<div class="paragraph">
<p>Modifiers are not mechanisms.
They do not return match or not-match.
Instead, they provide additional information.
Although modifiers do not directly affect the evaluation of the record, the
"redirect" modifier has an effect after all the mechanisms have been
evaluated.</p>
</div>
</div>
<div class="sect3">
<h4 id="_dns_lookup_limits"><a class="anchor" href="#_dns_lookup_limits"></a>4.6.4. DNS Lookup Limits</h4>
<div class="paragraph">
<p>The following terms cause DNS queries: the "include", "a", "mx", "ptr", and
"exists" mechanisms, and the "redirect" modifier.</p>
</div>
<div class="paragraph">
<p>SPF implementations MUST limit the total number of those terms to 10 during
SPF evaluation, to avoid unreasonable load on the DNS.
If this limit is exceeded, the implementation MUST return "permerror".</p>
</div>
<div class="paragraph">
<p>The other terms &#8212; the "all", "ip4", and "ip6" mechanisms, and the "exp"
modifier &#8212; do not cause DNS queries at the time of SPF evaluation (the
"exp" modifier only causes a lookup at a later time), and their use is not
subject to this limit.</p>
</div>
<div class="paragraph">
<p>When evaluating the "mx" mechanism, the number of "MX" resource records
queried is included in the overall limit of 10 mechanisms/modifiers that
cause DNS lookups as described above.
In addition to that limit, the evaluation of each "MX" record MUST NOT result
in querying more than 10 address records &#8212; either "A" or "AAAA" resource
records.
If this limit is exceeded, the "mx" mechanism MUST produce a "permerror"
result.</p>
</div>
<div class="paragraph">
<p>When evaluating the "ptr" mechanism or the %{p} macro, the number of "PTR"
resource records queried is included in the overall limit of 10
mechanisms/modifiers that cause DNS lookups as described above.
In addition to that limit, the evaluation of each "PTR" record MUST NOT result
in querying more than 10 address records &#8212; either "A" or "AAAA" resource
records.
If this limit is exceeded, all records other than the first 10 MUST be
ignored.</p>
</div>
<div class="paragraph">
<p>The <code>check_host()</code> elapsed time SHOULD have limited to least 20 seconds.
If such a limit is exceeded, the result of authorization SHOULD be
"temperror".</p>
</div>
<div class="paragraph">
<p>There may be cases where it is useful to limit the number of "terms" for which
DNS queries return either a positive answer (RCODE 0) with an answer count of
0, or a "Name Error" (RCODE 3) answer.
These are sometimes collectively referred to as "void lookups".
SPF implementations SHOULD limit "void lookups" to two.
An implementation MAY choose to make such a limit configurable.
In this case, a default of two is RECOMMENDED.
Exceeding the limit produces a "permerror" result.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_default_result"><a class="anchor" href="#_default_result"></a>4.7. Default Result</h3>
<div class="paragraph">
<p>If none of the mechanisms match and there is no "redirect" modifier, then the
check_host() returns a result of "neutral", just as if "?all" were specified
as the last directive.</p>
</div>
<div class="paragraph">
<p>If there is a "redirect" modifier, check_host() proceeds as defined in Section
6.1.</p>
</div>
<div class="paragraph">
<p>It is better to use either a "redirect" modifier or an "all" mechanism to
explicitly terminate processing.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>v=spf1 +mx -all</pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre>v=spf1 +mx redirect=_spf.example.com</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_domain_specification"><a class="anchor" href="#_domain_specification"></a>4.8. Domain Specification</h3>
<div class="paragraph">
<p>The &lt;domain-spec&gt; string is subject to macro expansion (see Section 7).
The resulting string is the common presentation form of a fully qualified DNS
name: a series of labels separated by periods.
This domain is called the &lt;target-name&gt; in the rest of this document.</p>
</div>
<div class="paragraph">
<p>For several mechanisms, the &lt;domain-spec&gt; is optional.
If it is not provided, the &lt;domain&gt; from the check_host() arguments (see
Section 4.1) is used as the &lt;target-name&gt;.
"domain" and &lt;domain-spec&gt; are syntactically identical after macro expansion.
"domain" is an input value for check_host(), while &lt;domain-spec&gt; is computed
by check_host().</p>
</div>
<div class="paragraph">
<p>The result of evaluating check_host() with a syntactically invalid domain is
undefined.
Examples include names with empty labels, such as "foo..example.com", and
labels that are longer than 63 characters.
Some implementations choose to treat such errors as not-match and therefore
ignore such names, while others return a "permerror" exception.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mechanism_definitions"><a class="anchor" href="#_mechanism_definitions"></a>5. Mechanism Definitions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section defines two types of mechanisms: basic language framework
mechanisms and designated sender mechanisms.</p>
</div>
<div class="paragraph">
<p>Basic mechanisms contribute to the language framework.
They do not specify a particular type of authorization scheme.
The basic mechanisms are as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>all
include</pre>
</div>
</div>
<div class="paragraph">
<p>Designated sender mechanisms are used to identify a set of &lt;ip&gt; addresses as
being permitted or not permitted to use the &lt;domain&gt; for sending mail.
The designated sender mechanisms are as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>a
mx
ptr (do not use)
ip4
ip6
exists</pre>
</div>
</div>
<div class="paragraph">
<p>The following conventions apply to all mechanisms that perform a comparison
between &lt;ip&gt; and an IP address at any point:</p>
</div>
<div class="paragraph">
<p>If no CIDR prefix length is given in the directive, then &lt;ip&gt; and the IP
address are compared for equality.</p>
</div>
<div class="paragraph">
<p>If a CIDR prefix length is specified, then only the specified number of
high-order bits of &lt;ip&gt; and the IP address are compared for equality.</p>
</div>
<div class="paragraph">
<p>When any mechanism fetches host addresses to compare with &lt;ip&gt;, when &lt;ip&gt; is
an IPv4, "A" records are fetched; when &lt;ip&gt; is an IPv6 address, "AAAA" records
are fetched.
SPF implementations on IPv6 servers need to handle both "AAAA" and "A"
records, for clients on IPv4-mapped IPv6 addresses [RFC4291].
IPv4 &lt;ip&gt; addresses are only listed in an SPF record using the "ip4"
mechanism.</p>
</div>
<div class="paragraph">
<p>Several mechanisms rely on information fetched from the DNS.
For these DNS queries, except where noted, if the DNS server returns an error
(RCODE other than 0 or 3) or the query times out, the mechanism stops and the
topmost check_host() returns "temperror".
If the server returns "Name Error" (RCODE 3), then evaluation of the mechanism
continues as if the server returned no error (RCODE 0) and zero answer
records.</p>
</div>
<div class="sect2">
<h3 id="_all"><a class="anchor" href="#_all"></a>5.1. "all"</h3>
<div class="listingblock">
<div class="content">
<pre>all = "all"</pre>
</div>
</div>
<div class="paragraph">
<p>The "all" mechanism is a test that always matches.
It is used as the rightmost mechanism in a record to provide an explicit
default.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>v=spf1 a mx -all</pre>
</div>
</div>
<div class="paragraph">
<p>Mechanisms after "all" will never be tested and MUST be ignored.</p>
</div>
<div class="paragraph">
<p>Any "redirect" modifier MUST be ignored when there is an "all" mechanism in
the record, regardless of the relative ordering of the terms.</p>
</div>
</div>
<div class="sect2">
<h3 id="_include"><a class="anchor" href="#_include"></a>5.2. "include"</h3>
<div class="listingblock">
<div class="content">
<pre>include = "include"  ":" domain-spec</pre>
</div>
</div>
<div class="paragraph">
<p>The "include" mechanism triggers a recursive evaluation of <code>check_host()</code>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The <code>&lt;domain-spec&gt;</code> is expanded as per <a href="#_macros">section 7</a>.</p>
</li>
<li>
<p><code>check_host()</code> is evaluated with the resulting string as the <code>&lt;domain&gt;</code>.
The <code>&lt;ip&gt;</code> and <code>&lt;sender&gt;</code> arguments remain the same as in the current
evaluation of <code>check_host()</code>.</p>
</li>
<li>
<p>The recursive evaluation returns match, not-match, or an error.</p>
</li>
<li>
<p>If it returns match, then the appropriate result for the "include"
mechanism is used (e.g., "include" or "+include" produces a "pass" result
and "-include" produces "fail").</p>
</li>
<li>
<p>If it returns not-match or an error, the parent <code>check_host()</code> resumes
processing as per the table below, with the previous value of <code>&lt;domain&gt;</code>
restored.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The "include" mechanism makes it possible for one domain to designate
multiple administratively independent domains.
For example, a vanity domain "example.net" might send mail using the servers
of administratively independent domains "example.com" and "example.org".</p>
</div>
<div class="paragraph">
<p>Example.net could say</p>
</div>
<div class="listingblock">
<div class="content">
<pre>IN TXT "v=spf1 include:example.com include:example.org -all"</pre>
</div>
</div>
<div class="paragraph">
<p>This would direct <code>check_host()</code> to, in effect, check the records of
"example.com" and "example.org" for a "pass" result.
Only if the host were not permitted for either of those domains would the
result be "fail".</p>
</div>
<div class="paragraph">
<p>Whether this mechanism matches, does not match, or returns an exception
depends on the result of the recursive evaluation of <code>check_host()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>
+-------------------------------------+------------------------------------+
| A recursive check_host() result of: | Causes the "include" mechanism to: |
+-------------------------------------+------------------------------------+
| pass                                | match                              |
| fail                                | not match                          |
| softfail                            | not match                          |
| neutral                             | not match                          |
| temperror                           | return temperror                   |
| permerror                           | return permerror                   |
| none                                | return permerror                   |
+-------------------------------------+------------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>The "include" mechanism is intended for crossing administrative boundaries.</p>
</div>
<div class="paragraph">
<p>When remaining within one administrative authority, "include" is usually
not the best choice.
For example, if example.com and example.org were managed by the same
entity, and if the permitted set of hosts for both domains was
"mx:example.com", it would be possible for example.org to specify
"include:example.com", but it would be preferable to specify
"redirect=example.com" or even "mx:example.com".</p>
</div>
<div class="paragraph">
<p>The "redirect" modifier is more suitable for consolidating both authorizations
and policy into a common set to be shared within an ADMD.
Redirect is much more like a common code element to be shared among records
in a single ADMD.
It is possible to control both authorized hosts and policy for an arbitrary
number of domains from a single record.</p>
</div>
</div>
<div class="sect2">
<h3 id="_a"><a class="anchor" href="#_a"></a>5.3. "a"</h3>
<div class="listingblock">
<div class="content">
<pre>a = "a" [ ":" domain-spec ] [ dual-cidr-length ]</pre>
</div>
</div>
<div class="paragraph">
<p>This mechanism matches if &lt;ip&gt; is one of the &lt;target-name&gt;'s IP addresses.
For clarity, this means the "a" mechanism also matches AAAA records.</p>
</div>
<div class="paragraph">
<p>An address lookup is done on the &lt;target-name&gt; using the type of lookup (A or
AAAA) appropriate for the connection type (IPv4 or IPv6).
The &lt;ip&gt; is compared to the returned address(es).
If any address matches, the mechanism matches.</p>
</div>
</div>
<div class="sect2">
<h3 id="_mx"><a class="anchor" href="#_mx"></a>5.4. "mx"</h3>
<div class="paragraph">
<p>This mechanism matches if &lt;ip&gt; is one of the MX hosts for a domain
name.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>mx               = "mx"     [ ":" domain-spec ] [ dual-cidr-length ]</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>check_host() first performs an MX lookup on the &lt;target-name&gt;.</p>
<div class="ulist">
<ul>
<li>
<p>To prevent denial-of-service (DoS) attacks, the processing limits
defined in Section 4.6.4 MUST be followed.</p>
</li>
<li>
<p>If the MX lookup limit is exceeded, then "permerror" is returned
and the evaluation is terminated.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Then it performs an address lookup on each MX name returned.</p>
</li>
<li>
<p>The &lt;ip&gt; is compared to each returned IP address.</p>
</li>
<li>
<p>If any address matches, the mechanism matches.</p>
</li>
<li>
<p>If the &lt;target-name&gt; has no MX record, check_host() MUST NOT apply
the implicit MX rules of [RFC5321] by querying for an A or AAAA
record for the same name.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_mechanism_ptr"><a class="anchor" href="#_mechanism_ptr"></a>5.5. "ptr" (do not use)</h3>
<div class="paragraph">
<p>This mechanism tests whether the DNS reverse-mapping for &lt;ip&gt; exists and
correctly points to a domain name within a particular domain.
This mechanism SHOULD NOT be published.</p>
</div>
<div class="paragraph">
<p>The &lt;ip&gt;'s name is looked up using this procedure:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Perform a DNS reverse-mapping for &lt;ip&gt;: Look up the corresponding
PTR record in "in-addr.arpa." if the address is an IPv4 address
and in "ip6.arpa." if it is an IPv6 address.</p>
</li>
<li>
<p>Check all domain names to see if they either match the &lt;target-name&gt; domain
or are a subdomain of the &lt;target-name&gt; domain.</p>
</li>
<li>
<p>If any do, this domain name can be validated.</p>
</li>
<li>
<p>If no domain name can be found, or if none of the domain names match or
are a subdomain of the &lt;target-name&gt;, this mechanism fails to match.</p>
</li>
<li>
<p>If a DNS error occurs while doing the PTR RR lookup, then this mechanism
fails to match.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This mechanism may match if</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a validated domain name is a subdomain of the &lt;target-name&gt;, or</p>
</li>
<li>
<p>the &lt;target-name&gt; and a domain name are the same.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, "mail.example.com" is within the domain "example.com",
but "mail.bad-example.com" is not.</p>
</div>
<div class="paragraph">
<p>The domain names received must also be validated for the mechanism to match.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For each matched record, validate the domain name by looking up
its IP addresses.
To prevent DoS attacks, the PTR processing limits defined in Section 4.6.4
MUST be applied.
If they are exceeded, processing is terminated and the mechanism does not
match.</p>
</li>
<li>
<p>If &lt;ip&gt; is among the returned IP addresses, then that domain name is
validated.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If a DNS error occurs while doing an A RR lookup, then that domain name is
skipped and the search continues.</p>
</div>
<div class="paragraph">
<p>The mechanism matches if a domain name is found that properly matches the
target name and can be properly validated.
While these tests can be done in either order, performing the match before
validating prevents needless DNS queries being performed.</p>
</div>
<div class="paragraph">
<p>Note: This mechanism is not as reliable as other mechanisms in cases of DNS
errors.
If used, proper PTR records have to be in place for the domain&#8217;s hosts and the
"ptr" mechanism SHOULD be one of the last mechanisms checked.
After many years of SPF deployment experience, it has been concluded that it
is unnecessary and more reliable alternatives should be used instead.
It is, however, still in use as part of the SPF protocol, so compliant
check_host() implementations MUST support it.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ip4_and_ip6"><a class="anchor" href="#_ip4_and_ip6"></a>5.6. "ip4" and "ip6"</h3>
<div class="paragraph">
<p>These mechanisms test whether &lt;ip&gt; is contained within a given IP network.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ip4              = "ip4"      ":" ip4-network   [ ip4-cidr-length ]
ip6              = "ip6"      ":" ip6-network   [ ip6-cidr-length ]

ip4-cidr-length  = "/" ("0" / %x31-39 0*1DIGIT) ; value range 0-32
ip6-cidr-length  = "/" ("0" / %x31-39 0*2DIGIT) ; value range 0-128
dual-cidr-length = [ ip4-cidr-length ] [ "/" ip6-cidr-length ]

ip4-network      = qnum "." qnum "." qnum "." qnum
qnum             = DIGIT                 ; 0-9
                   / %x31-39 DIGIT       ; 10-99
                   / "1" 2DIGIT          ; 100-199
                   / "2" %x30-34 DIGIT   ; 200-249
                   / "25" %x30-35        ; 250-255
                 ; as per conventional dotted-quad notation, e.g., 192.0.2.0

ip6-network      = &lt;as per Section 2.2 of [RFC4291]&gt;
                 ; e.g., 2001:db8::cd30</pre>
</div>
</div>
<div class="paragraph">
<p>The &lt;ip&gt; is compared to the given network.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If CIDR prefix length high-order bits match, the mechanism matches.</p>
</li>
<li>
<p>If ip4-cidr-length is omitted, it is taken to be "/32".</p>
</li>
<li>
<p>If ip6-cidr-length is omitted, it is taken to be "/128".</p>
</li>
<li>
<p>It is not permitted to omit parts of the IP address instead of using CIDR
notations.
That is, use 192.0.2.0/24 instead of 192.0.2.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_exist"><a class="anchor" href="#_exist"></a>5.7. "exist"</h3>
<div class="paragraph">
<p>This mechanism is used to construct an arbitrary domain name that is used for
a DNS A record query.
It allows for complicated schemes involving arbitrary parts of the mail
envelope to determine what is permitted.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>exists           = "exists"   ":" domain-spec</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The resulting domain name is used for a DNS A RR lookup (even when the
connection type is IPv6).</p>
</li>
<li>
<p>If any A record is returned, this mechanism matches.</p>
</li>
<li>
<p>Domains can use this mechanism to specify arbitrarily complex queries.
For example, suppose example.com publishes the record:
&#8230;.
v=spf1 exists:%{ir}.%{l1r+-}._spf.%{d} -all
&#8230;.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The &lt;target-name&gt; might expand to "1.2.0.192.someuser._spf.example.com".
This makes fine-grained decisions possible at the level of the user and client
IP address.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_modifier_definitions"><a class="anchor" href="#_modifier_definitions"></a>6. Modifier Definitions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Modifiers are name/value pairs that provide additional information.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Modifiers always have an "=" separating the name and the value.</p>
</li>
<li>
<p>The modifiers defined in this document ("redirect" and "exp") SHOULD appear
at the end of the record, after all mechanisms, though syntactically they
can appear anywhere in the record.</p>
</li>
<li>
<p>Ordering of these two modifiers does not matter.</p>
</li>
<li>
<p>These two modifiers MUST NOT appear in a record more than once each.
If they do, then check_host() exits with a result of "permerror".</p>
</li>
<li>
<p>Unrecognized modifiers MUST be ignored no matter where, or how often,
they appear in a record.
This allows implementations conforming to this document to gracefully
handle records with modifiers that are defined in other specifications.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_redirect_redirected_query"><a class="anchor" href="#_redirect_redirected_query"></a>6.1. redirect: Redirected Query</h3>
<div class="paragraph">
<p>The "redirect" modifier is intended for consolidating both authorizations and
policy into a common set to be shared within a single ADMD.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>redirect         = "redirect" "=" domain-spec</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>For clarity, any "redirect" modifier SHOULD appear as the very last
term in a record.</p>
</li>
<li>
<p>Any "redirect" modifier MUST be ignored if there is an "all" mechanism
anywhere in the record.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If all mechanisms fail to match, and a "redirect" modifier is present, then
processing proceeds as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The &lt;domain-spec&gt; portion of the redirect section is expanded as per
the macro rules in Section 7.</p>
<div class="ulist">
<ul>
<li>
<p>Then check_host() is evaluated with the resulting string as the &lt;domain&gt;.</p>
</li>
<li>
<p>The &lt;ip&gt; and &lt;sender&gt; arguments remain the same as in the current
evaluation of check_host().</p>
</li>
</ul>
</div>
</li>
<li>
<p>The result of this new evaluation of check_host() is then considered
the result of the current evaluation with the exception that if no
SPF record is found, or if the &lt;target-name&gt; is malformed, the result
is a "permerror" rather than "none".</p>
</li>
<li>
<p>Note that the newly queried domain can itself specify redirect processing.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This facility is intended for use by organizations that wish to apply the same
record to multiple domains.  For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>la.example.com. TXT "v=spf1 redirect=_spf.example.com"
ny.example.com. TXT "v=spf1 redirect=_spf.example.com"
sf.example.com. TXT "v=spf1 redirect=_spf.example.com"
_spf.example.com. TXT "v=spf1 mx:example.com -all"</pre>
</div>
</div>
<div class="paragraph">
<p>In this example, mail from any of the three domains is described by the same
record.
This can be an administrative advantage.</p>
</div>
<div class="paragraph">
<p>Note: In general, the domain "A" cannot reliably use a redirect to another
domain "B" not under the same administrative control.
Since the &lt;sender&gt; stays the same, there is no guarantee that the record at
domain "B" will correctly work for mailboxes in domain "A", especially if
domain "B" uses mechanisms involving local-parts.
An "include" directive will generally be more appropriate.</p>
</div>
</div>
<div class="sect2">
<h3 id="_exp_explanation"><a class="anchor" href="#_exp_explanation"></a>6.2. exp: Explanation</h3>
<div class="literalblock">
<div class="content">
<pre>explanation      = "exp" "=" domain-spec</pre>
</div>
</div>
<div class="paragraph">
<p>If check_host() results in a "fail" due to a mechanism match (such as "-all"),
and the "exp" modifier is present, then the explanation string returned is
computed as described below.</p>
</div>
<div class="paragraph">
<p>If no "exp" modifier is present, then either a default explanation string or
an empty explanation string MUST be returned to the calling application.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The &lt;domain-spec&gt; is macro expanded (see Section 7) and becomes the
&lt;target-name&gt;.</p>
</li>
<li>
<p>The DNS TXT RRset for the &lt;target-name&gt; is fetched.</p>
</li>
<li>
<p>If there are any DNS processing errors (any RCODE other than 0), or
if no records are returned, or if more than one record is returned,
or if there are syntax errors in the explanation string, then proceed
as if no "exp" modifier was given.</p>
</li>
<li>
<p>The fetched TXT record&#8217;s strings are concatenated with no spaces, and
then treated as an explain-string, which is macro-expanded.
This final result is the explanation string.</p>
</li>
<li>
<p>Implementations MAY limit the length of the resulting explanation string to
allow for other protocol constraints and/or reasonable processing limits.</p>
</li>
<li>
<p>Since the explanation string is intended for an SMTP response and Section
2.4 of [RFC5321] says that responses are in [US-ASCII], the explanation
string MUST be limited to [US-ASCII].</p>
</li>
<li>
<p>Software evaluating check_host() can use this string to communicate
information from the publishing domain in the form of a short message
or URL.</p>
</li>
<li>
<p>Software SHOULD make it clear that the explanation string comes from a
third party.
For example, it can prepend the macro string "%{o} explains: " to the
explanation.</p>
</li>
<li>
<p>During recursion into an "include" mechanism, an "exp" modifier
from the &lt;target-name&gt; MUST NOT be used.
This is because "include" is meant to cross administrative boundaries and
the explanation provided should be the one from the receiving ADMD.</p>
</li>
<li>
<p>In contrast, when executing a "redirect" modifier, an "exp" modifier from
the original domain MUST NOT be used.
"redirect" is meant to operate as a tool to consolidate policy records
within an ADMD so the redirected explanation is the one that ought to have
priority.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here are some examples of possible explanation TXT records at
explain._spf.example.com:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"Mail from example.com should only be sent by its own servers."</pre>
</div>
</div>
<div class="paragraph">
<p>&#8212; a simple, constant message</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"%{i} is not one of %{d}'s designated mail servers."</pre>
</div>
</div>
<div class="paragraph">
<p>&#8212; a message with a little more information, including the IP address that
failed the check</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"See http://%{d}/why.html?s=%{S}&amp;i=%{I}"</pre>
</div>
</div>
<div class="paragraph">
<p>&#8212; a complicated example that constructs a URL with the arguments to
check_host() so that a web page can be generated with detailed, custom
instructions</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_macros"><a class="anchor" href="#_macros"></a>7. Macros</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_formal_specification"><a class="anchor" href="#_formal_specification"></a>7.1. Formal Specification</h3>
<div class="literalblock">
<div class="content">
<pre>domain-spec      = macro-string domain-end

domain-end       = ( "." toplabel [ "." ] ) / macro-expand

toplabel         = ( *alphanum ALPHA *alphanum ) /
                   ( 1*alphanum "-" *( alphanum / "-" ) alphanum )

alphanum         = ALPHA / DIGIT

explain-string   = *( macro-string / SP )

macro-string     = *( macro-expand / macro-literal )

macro-expand     = ( "%{" macro-letter transformers *delimiter "}" )
                   / "%%" / "%_" / "%-"

macro-literal    = %x21-24 / %x26-7E
                   ; visible characters except "%"

macro-letter     = "s" / "l" / "o" / "d" / "i" / "p" / "h" /
                   "c" / "r" / "t" / "v"

transformers     = *DIGIT [ "r" ]

delimiter        = "." / "-" / "+" / "," / "/" / "_" / "="</pre>
</div>
</div>
<div class="paragraph">
<p>Some special cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A literal "%" is expressed by "%%".</p>
</li>
<li>
<p>"%_" expands to a single " " space.</p>
</li>
<li>
<p>"%-" expands to a URL-encoded space, viz., "%20".</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_macro_definitions"><a class="anchor" href="#_macro_definitions"></a>7.2. Macro Definitions</h3>
<div class="paragraph">
<p>The following macro letters are expanded in term arguments:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>s = &lt;sender&gt;
l = local-part of &lt;sender&gt;
o = domain of &lt;sender&gt;
d = &lt;domain&gt;
i = &lt;ip&gt;
p = the validated domain name of &lt;ip&gt; (do not use)
v = the string "in-addr" if &lt;ip&gt; is ipv4, or "ip6" if &lt;ip&gt; is ipv6
h = HELO/EHLO domain</pre>
</div>
</div>
<div class="paragraph">
<p>The following macro letters are allowed only in "exp" text:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>c = SMTP client IP (easily readable format)
r = domain name of host performing the check
t = current timestamp</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_macro_processing_details"><a class="anchor" href="#_macro_processing_details"></a>7.3. Macro Processing Details</h3>
<div class="paragraph">
<p>A '%' character not followed by a '{', '%', '-', or '_' character is a syntax
error.
So:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        -exists:%(ir).sbl.example.org</pre>
</div>
</div>
<div class="paragraph">
<p>is incorrect and will cause check_host() to yield a "permerror".
Instead, the following is legal:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        -exists:%{ir}.sbl.example.org</pre>
</div>
</div>
<div class="paragraph">
<p>Optional transformers are the following:</p>
</div>
<div class="paragraph">
<p>*DIGIT = zero or more digits</p>
</div>
<div class="literalblock">
<div class="content">
<pre>'r'    = reverse value, splitting on dots by default</pre>
</div>
</div>
<div class="paragraph">
<p>If transformers or delimiters are provided, the replacement value for a macro
letter is split into parts separated by one or more of the specified delimiter
characters.
After performing any reversal operation and/or removal of left-hand parts, the
parts are rejoined using "." and not the original splitting characters.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>By default, strings are split on "." (dots).</p>
</li>
<li>
<p>Note that no special treatment is given to leading, trailing, or
consecutive delimiters in input strings, and so the list of parts might
contain empty strings.</p>
</li>
<li>
<p>Some older implementations of SPF prohibit trailing dots in domain names,
so trailing dots SHOULD NOT be published, although they MUST be accepted by
implementations conforming to this document.</p>
</li>
<li>
<p>Macros can specify delimiter characters that are used instead of ".".</p>
</li>
<li>
<p>The "r" transformer indicates a reversal operation: if the client IP
address were 192.0.2.1, the macro %{i} would expand to "192.0.2.1"
and the macro %{ir} would expand to "1.2.0.192".</p>
</li>
<li>
<p>The DIGIT transformer indicates the number of right-hand parts to use,
after optional reversal.</p>
<div class="ulist">
<ul>
<li>
<p>If a DIGIT is specified, the value MUST be nonzero.</p>
</li>
<li>
<p>If no DIGITs are specified, or if the value specifies more parts than are
available, all the available parts are used.</p>
</li>
<li>
<p>If the DIGIT was 5, and only 3 parts were available, the macro
interpreter would pretend the DIGIT was 3.</p>
</li>
<li>
<p>Implementations MUST support at least a value of 127, as that is the
maximum number of labels in a domain name (less the zero-length label at
the end).</p>
</li>
</ul>
</div>
</li>
<li>
<p>The "s" macro expands to the &lt;sender&gt; argument.
It is an email address with a local-part, an "@" character, and a domain.</p>
</li>
<li>
<p>The "l" macro expands to just the local-part.</p>
</li>
<li>
<p>The "o" macro expands to just the domain part.</p>
</li>
<li>
<p>Note that "s", "l", and "o" values remain the same during recursive and
chained evaluations due to "include" and/or "redirect".</p>
</li>
<li>
<p>If the original &lt;sender&gt; had no local-part, the local-part was set to
"postmaster" in initial processing (see Section 4.3).</p>
</li>
<li>
<p>For IPv4 addresses, both the "i" and "c" macros expand to the standard
dotted-quad format.</p>
</li>
<li>
<p>For IPv6 addresses, the "i" macro expands to a dot-format address; it
is intended for use in %{ir}.</p>
</li>
<li>
<p>The "c" macro can expand to any of the hexadecimal colon-format addresses
specified in Section 2.2 of [RFC4291].
It is intended for humans to read.</p>
</li>
<li>
<p>The "p" macro expands to the validated domain name of &lt;ip&gt;.
The procedure for finding the validated domain name is defined in
<a href="#_mechanism_ptr">Section 5.5</a>.</p>
<div class="ulist">
<ul>
<li>
<p>If the &lt;domain&gt; is present in the list of validated domains, it SHOULD be
used.</p>
</li>
<li>
<p>Otherwise, if a subdomain of the &lt;domain&gt; is present, it SHOULD be used.</p>
</li>
<li>
<p>Otherwise, any name from the list can be used.</p>
</li>
<li>
<p>If there are no validated domain names or if a DNS error occurs, the
string "unknown" is used.</p>
</li>
<li>
<p>This macro SHOULD NOT be published (see
<a href="#_mechanism_ptr">Section 5.5</a>
for the discussion).</p>
</li>
</ul>
</div>
</li>
<li>
<p>The "h" macro expands to the parameter that was provided to the SMTP
server via the HELO or EHLO SMTP verb.
For sessions where that verb was provided more than once, the most recent
instance is used.</p>
</li>
<li>
<p>The "r" macro expands to the name of the receiving MTA.
This SHOULD be a fully qualified domain name, but if one does not exist (as
when the checking is done by a Mail User Agent (MUA)) or if policy
restrictions dictate otherwise, the word "unknown" SHOULD be substituted.
The domain name can be different from the name found in the MX record that
the client MTA used to locate the receiving MTA.</p>
</li>
<li>
<p>The "t" macro expands to the decimal representation of the approximate
number of seconds since the Epoch (Midnight, January 1, 1970, UTC) at the time
of the evaluation.
This is the same value as the value that is returned by the
Portable Operating System Interface (POSIX) time() function in most
standards-compliant libraries.</p>
</li>
<li>
<p>When the result of macro expansion is used in a domain name query,
if the expanded domain name exceeds 253 characters (the maximum
length of a domain name in this format), the left side is truncated
to fit, by removing successive domain labels (and their following
dots) until the total length does not exceed 253 characters.</p>
</li>
<li>
<p>Uppercase macros expand exactly as their lowercase equivalents, and
are then URL escaped.
URL escaping MUST be performed for characters not in the
"unreserved" set, which is defined in [RFC3986].</p>
</li>
<li>
<p>Care has to be taken by the sending ADMD so that macro expansion
for legitimate email does not exceed the 63-character limit on DNS
labels.
The local-part of email addresses, in particular, can have
more than 63 characters between dots.</p>
</li>
<li>
<p>To minimize DNS lookup resource requirements, it is better if
sending ADMDs avoid using the "s", "l", "o", or "h" macros in
conjunction with any mechanism directive.
Although these macros are powerful and allow per-user records to be
published, they severely limit the ability of implementations to
cache results of check_host() and they reduce the effectiveness of
DNS caches.</p>
</li>
<li>
<p>If no directive processed during the evaluation of check_host()
contains an "s", "l", "o", or "h" macro, then the results of the
evaluation can be cached on the basis of &lt;domain&gt; and &lt;ip&gt; alone
for as long as the DNS record involved with the shortest Time to
Live (TTL) has not expired.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_expansion_examples"><a class="anchor" href="#_expansion_examples"></a>7.4. Expansion Examples</h3>
<div class="paragraph">
<p>The &lt;sender&gt; is strong-bad@email.example.com.
The IPv4 SMTP client IP is 192.0.2.3.
The IPv6 SMTP client IP is 2001:db8::cb01.
The PTR domain name of the client IP is mx.example.org.</p>
</div>
<div class="paragraph">
<p>Example of macro expansion,</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>%{s}</code>: strong-bad@email.example.com</p>
</li>
<li>
<p><code>%{o}</code>: email.example.com</p>
</li>
<li>
<p><code>%{d}</code>: email.example.com</p>
</li>
<li>
<p><code>%{d4}</code>: email.example.com</p>
</li>
<li>
<p><code>%{d3}</code>: email.example.com</p>
</li>
<li>
<p><code>%{d2}</code>: example.com</p>
</li>
<li>
<p><code>%{d1}</code>: com</p>
</li>
<li>
<p><code>%{dr}</code>: com.example.email</p>
</li>
<li>
<p><code>%{d2r}</code>: example.email</p>
</li>
<li>
<p><code>%{l}</code>: strong-bad</p>
</li>
<li>
<p><code>%{l-}</code>: strong.bad</p>
</li>
<li>
<p><code>%{lr}</code>: strong-bad</p>
</li>
<li>
<p><code>%{lr-}</code>: bad.strong</p>
</li>
<li>
<p><code>%{l1r-}</code>: strong</p>
</li>
<li>
<p><code>%{ir}.%{v}._spf.%{d2}: `3.2.0.192.in-addr._spf.example.com</code>
</p>
</li>
<li>
<p><code>%{lr-}.lp._spf.%{d2}</code>: <code>bad.strong.lp._spf.example.com</code>
</p>
</li>
<li>
<p><code>%{lr-}.lp.%{ir}.%{v}._spf.%{d2}</code>: bad.strong.lp.3.2.0.192.in-addr._spf.example.com</p>
</li>
<li>
<p><code>%{ir}.%{v}.%{l1r-}.lp._spf.%{d2}</code>: 3.2.0.192.in-addr.strong.lp._spf.example.com</p>
</li>
<li>
<p><code>%{d2}.trusted-domains.example.net</code>: example.com.trusted-domains.example.net</p>
</li>
<li>
<p><code>%{ir}.%{v}._spf.%{d2}</code>: <code>1.0.b.c.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6._spf.example.com</code>
</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_result_handling"><a class="anchor" href="#_result_handling"></a>8. Result Handling</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are essentially two classes of handling choices:</p>
</div>
<div class="paragraph">
<p>-  Handling within the SMTP session that attempted to deliver the
 message, such as by returning a permanent SMTP error (rejection) or
 temporary SMTP error ("try again later");</p>
</div>
<div class="paragraph">
<p>-  Permitting the message to pass (a successful SMTP reply code) and
 adding an additional header field that indicates the result
 returned by check_host() and other salient details; this is
 discussed in more detail in Section 9.</p>
</div>
<div class="sect2">
<h3 id="_none"><a class="anchor" href="#_none"></a>8.1. None</h3>
<div class="paragraph">
<p>The SPF verifier has no information at all about the authorization or
lack thereof of the client to use the checked identity or identities.
The check_host() function completed without errors but was not able to
reach any conclusion.</p>
</div>
</div>
<div class="sect2">
<h3 id="_neutral"><a class="anchor" href="#_neutral"></a>8.2. Neutral</h3>
<div class="paragraph">
<p>A policy for the identity was discovered, there is no definite
assertion (positive or negative) about the client.</p>
</div>
<div class="paragraph">
<p>A "neutral" result MUST be treated exactly like the "none" result; the
distinction exists only for informational purposes.
Treating "neutral" more harshly than "none" would discourage ADMDs
from testing the use of SPF records (see Section 10.1).</p>
</div>
</div>
<div class="sect2">
<h3 id="_pass"><a class="anchor" href="#_pass"></a>8.3. Pass</h3>
<div class="paragraph">
<p>The client is authorized to inject mail with the given identity.
The domain can now, in the sense of reputation, be considered
responsible for sending the message.
Further policy checks can now proceed with confidence in the
legitimate use of the identity.
This is further discussed in Appendix G.1.</p>
</div>
</div>
<div class="sect2">
<h3 id="_fail"><a class="anchor" href="#_fail"></a>8.4. Fail</h3>
<div class="paragraph">
<p>The client is not authorized to use the domain in the given identity.
Disposition of SPF fail messages is a matter of local policy.
See Appendix G.2 for considerations on developing local policy.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the checking software chooses to reject the mail during the SMTP
transaction, then it SHOULD use an SMTP reply code of 550 (see
[RFC5321]) and, if supported, the 5.7.1 enhanced status code (see
[RFC3463], Section 3.8), in addition to an appropriate reply text.</p>
</li>
<li>
<p>The check_host() function will return either a default explanation
string or one from the domain that published the SPF records (see
Section 6.2).</p>
</li>
<li>
<p>If the information does not originate with the checking software,
it is good to make it clear that the text is provided by the
sender&#8217;s domain.  For example:</p>
<div class="literalblock">
<div class="content">
<pre>550 5.7.1 SPF MAIL FROM check failed:
550 5.7.1 The domain example.com explains:
550 5.7.1 Please see http://www.example.com/mailpolicy.html</pre>
</div>
</div>
</li>
<li>
<p>If the checking software chooses not to reject the mail during the
SMTP transaction, then it SHOULD add a Received-SPF or
Authentication-Results header field (see Section 9) to communicate
this result to downstream message processors.
While this is true for all SPF results, it is of particular
importance for "fail" results since the message is explicitly not
authorized by the ADMD.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_softfail"><a class="anchor" href="#_softfail"></a>8.5. Softfail</h3>
<div class="paragraph">
<p>A "softfail" result ought to be treated as somewhere between "fail"
and "neutral"/"none".
The ADMD believes the host is not authorized but is not willing to
make a strong policy statement.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Receiving software SHOULD NOT reject the message based solely on
this result, but MAY subject the message to closer scrutiny than
normal.</p>
</li>
<li>
<p>The ADMD wants to discourage the use of this host and thus desires
limited feedback when a "softfail" result occurs.
For example, the recipient&#8217;s MUA could highlight the "softfail"
status, or the receiving MTA could give the sender a message using
greylisting [RFC6647], with a note the first time the message is
received, but accept it on a later attempt based on receiver
policy.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_temperror"><a class="anchor" href="#_temperror"></a>8.6. Temperror</h3>
<div class="paragraph">
<p>The SPF verifier encountered a transient (generally DNS) error while
performing the check.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Checking software can choose to accept or temporarily reject the
message.</p>
</li>
<li>
<p>If the message is rejected during the SMTP transaction for this reason, the
software SHOULD use an SMTP reply code of 451 and, if supported,
the 4.4.3 enhanced status code (see Section 3.5 of [RFC3463]).</p>
</li>
<li>
<p>These errors can be caused by problems in either the sender&#8217;s or
receiver&#8217;s DNS software.
See Appendix G.4 for considerations on developing local policy.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_permerror"><a class="anchor" href="#_permerror"></a>8.7. Permerror</h3>
<div class="paragraph">
<p>The domain&#8217;s published records could not be correctly interpreted.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This signals an error condition that definitely requires DNS
operator intervention to be resolved.</p>
</li>
<li>
<p>If the message is rejected during the SMTP transaction for this
reason, the software SHOULD use an SMTP reply code of 550 and, if
supported, the 5.5.2 enhanced status code (see [RFC3463], Section
3.6).</p>
</li>
<li>
<p>Be aware that if the ADMD uses macros (Section 7), it is possible that this
result is due to the checked identities having an unexpected
format.</p>
</li>
<li>
<p>It is also possible that this result is generated by certain SPF
verifiers due to the input arguments having an unexpected format;
see Section 4.8.</p>
</li>
<li>
<p>See Appendix G.3 for considerations on developing local policy.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_recording_the_result"><a class="anchor" href="#_recording_the_result"></a>9. Recording the Result</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It is RECOMMENDED that SMTP receivers record the result of SPF
processing in the message header.</p>
</div>
<div class="paragraph">
<p>Two methods are presented:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Section 9.1 defines the Received-SPF field, which is the results
field originally defined for SPF use.</p>
<div class="ulist">
<ul>
<li>
<p>Received-SPF is intended to include enough information to enable
reconstruction of the SPF evaluation of the message.</p>
</li>
<li>
<p>Received-SPF relies on compliance of agents within the receiving
ADMD to adhere to the header field ordering rules of [RFC5321] and
[RFC5322]</p>
</li>
</ul>
</div>
</li>
<li>
<p>Section 9.2 discusses the Authentication-Results header field
[RFC7001], which was specified more recently and is designed for
use by SPF and other authentication methods.</p>
<div class="ulist">
<ul>
<li>
<p>Authentication-Results is designed only to relay the result itself
and related output details of likely use to end users (e.g., what
property of the message was actually authenticated and what it
contained), leaving reconstructive work to the purview of system
logs and the Received field contents.</p>
</li>
<li>
<p>Authentication-Results includes some provisions to protect against
non-compliant implementations.</p>
</li>
</ul>
</div>
</li>
<li>
<p>An SPF verifier operator could choose to use both to serve
different downstream agents.
In such cases, care needs to be taken to ensure that both fields
are conveying the same details, or unexpected results can occur.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_the_received_spf_header_field"><a class="anchor" href="#_the_received_spf_header_field"></a>9.1. The Received-SPF Header Field</h3>
<div class="ulist">
<ul>
<li>
<p>The Received-SPF header field is a trace field (see [RFC5322],
Section 3.6.7) and SHOULD be prepended to the existing header,
above the Received: field that is generated by the SMTP receiver.</p>
</li>
<li>
<p>It MUST appear above all other Received-SPF fields in the message.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The header field has the following format:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>header-field     = "Received-SPF:" [CFWS] result FWS [comment FWS]
[ key-value-list ] CRLF</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>result           = "pass" / "fail" / "softfail" / "neutral" /
"none" / "temperror" / "permerror"</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>key-value-list   = key-value-pair *( ";" [CFWS] key-value-pair )
[";"]</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>key-value-pair   = key [CFWS] "=" ( dot-atom / quoted-string )</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>key              = "client-ip" / "envelope-from" / "helo" /
"problem" / "receiver" / "identity" /
"mechanism" / name</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>identity         = "mailfrom"   ; for the "MAIL FROM" identity
/ "helo"     ; for the "HELO" identity
/ name       ; other identities</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>dot-atom         = &lt;unquoted word as per [RFC5322]&gt;
quoted-string    = &lt;quoted string as per [RFC5322]&gt;
comment          = &lt;comment string as per [RFC5322]&gt;
CFWS             = &lt;comment or folding white space as per [RFC5322]&gt;
FWS              = &lt;folding white space as per [RFC5322]&gt;
CRLF             = &lt;standard end-of-line token as per [RFC5322]&gt;</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The header field SHOULD include a "(&#8230;)" style comment after the
result, conveying supporting information for the result, such as
&lt;ip&gt;, &lt;sender&gt;, and &lt;domain&gt;.</p>
</li>
<li>
<p>SPF verifiers SHOULD give enough information so that the SPF
results can be verified &#8212; that is, at least "client-ip", "helo",
and, if the "MAIL FROM" identity was checked, "envelope-from".</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following key-value pairs are designed for later machine parsing,</p>
</div>
<div class="ulist">
<ul>
<li>
<p>client-ip: the IP address of the SMTP client</p>
</li>
<li>
<p>envelope-from: the envelope sender mailbox</p>
</li>
<li>
<p>helo: the host name given in the HELO or EHLO command</p>
</li>
<li>
<p>mechanism: the mechanism that matched (if no mechanisms matched,
substitute the word "default")</p>
</li>
<li>
<p>problem: if an error was returned, details about the error</p>
</li>
<li>
<p>receiver: the host name of the SPF verifier</p>
</li>
<li>
<p>identity: the identity that was checked; see the &lt;identity&gt; ABNF
rule</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other keys MAY be defined by SPF verifiers.</p>
</div>
<div class="paragraph">
<p>SPF verifiers MUST make sure that the Received-SPF header field does
not contain invalid characters, is not excessively long (see
[RFC5322], Section 2.1.1), and does not contain malicious data that
has been provided by the sender.</p>
</div>
<div class="paragraph">
<p>Examples of various header field styles that could be generated are
the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Received-SPF: pass (mybox.example.org: domain of
 myname@example.com designates 192.0.2.1 as permitted sender)
   receiver=mybox.example.org; client-ip=192.0.2.1;
   envelope-from="myname@example.com"; helo=foo.example.com;

Received-SPF: fail (mybox.example.org: domain of
                 myname@example.com does not designate
                 192.0.2.1 as permitted sender)
                 identity=mailfrom; client-ip=192.0.2.1;
                 envelope-from="myname@example.com";

Received-SPF: pass (mybox.example.org: domain of
    myname@example.com designates 192.0.2.1 as permitted sender)
       receiver=mybox.example.org; client-ip=192.0.2.1;
       mechanism=ip4:192.0.2.1; envelope-from="myname@example.com";
       helo=foo.example.com;</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_spf_results_in_the_authentication_results_header_field"><a class="anchor" href="#_spf_results_in_the_authentication_results_header_field"></a>9.2. SPF Results in the Authentication-Results Header Field</h3>
<div class="paragraph">
<p>The Authentication-Results header field is designed to communicate
lists of tests a border MTA did and their results.
The specified elements of the field provide less information than the
Received-SPF field:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>   Authentication-Results: myhost.example.org; spf=pass
     smtp.mailfrom=example.net

   Received-SPF: pass (myhost.example.org: domain of
    myname@example.com designates 192.0.2.1 as permitted sender)
       receiver=mybox.example.org; client-ip=192.0.2.1;
       envelope-from="myname@example.com"; helo=foo.example.com;</pre>
</div>
</div>
<div class="paragraph">
<p>It is, however, possible to add CFWS in the "reason" part of an
Authentication-Results header field and provide the equivalent
information, if desired.</p>
</div>
<div class="paragraph">
<p>As an example, an expanded Authentication-Results header field might
look like (for a "MAIL FROM" check in this example):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>   Authentication-Results: myhost.example.org; spf=pass
     reason="client-ip=192.0.2.1; smtp.helo=foo.example.com"
     smtp.mailfrom=user@example.net</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_effects_on_infrastructure"><a class="anchor" href="#_effects_on_infrastructure"></a>10. Effects on Infrastructure</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section provides operational advice and instruction only.
It is non-normative.</p>
</div>
<div class="sect2">
<h3 id="_sending_domains"><a class="anchor" href="#_sending_domains"></a>10.1. Sending Domains</h3>
<div class="paragraph">
<p>Originating ADMDs that wish to be compliant with this specification
will need to determine the list of relays ([RFC5598], Section 2.2.2)
that they allow to use their domain name in the "HELO" and "MAIL FROM"
identities when relaying to other ADMDs.
It is recognized that forming such a list is not just a simple
technical exercise, but involves policy decisions with both technical
and administrative considerations.</p>
</div>
<div class="sect3">
<h4 id="_dns_resource_considerations"><a class="anchor" href="#_dns_resource_considerations"></a>10.1.1. DNS Resource Considerations</h4>
<div class="paragraph">
<p>For example, consider a domain set up as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>example.com.     IN MX   10 mx.example.com.
IN MX   20 mx2.example.com.
mx.example.com.  IN A    192.0.2.1
mx2.example.com. IN A    192.0.2.129</pre>
</div>
</div>
<div class="paragraph">
<p>Assume the administrative point is to authorize (pass) mx and mx2
while failing every other host.
Compare the following solutions:</p>
</div>
<div class="paragraph">
<p>Best record:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>example.com.   IN TXT  "v=spf1 ip4:192.0.2.1 ip4:192.0.2.129 -all"</pre>
</div>
</div>
<div class="paragraph">
<p>Good record:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ORIGIN example.com.
@              IN TXT  "v=spf1 a:authorized-spf.example.com -all"
authorized-spf IN A    192.0.2.1
IN A    192.0.2.129</pre>
</div>
</div>
<div class="paragraph">
<p>Expensive record:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>example.com.   IN TXT  "v=spf1 mx:example.com -all"</pre>
</div>
</div>
<div class="paragraph">
<p>Wasteful, bad record:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>example.com.   IN TXT  "v=spf1 ip4:192.0.2.0/24 mx -all"</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_administrator_8217_s_considerations"><a class="anchor" href="#_administrator_8217_s_considerations"></a>10.1.2. Administrator&#8217;s Considerations</h4>
<div class="paragraph">
<p>There might be administrative considerations: using "a" over "ip4" or
"ip6" allows hosts to be renumbered easily at the cost of a DNS query
per receiver.
Using "mx" over "a" allows the set of mail hosts to be changed easily.
Unless such changes are common, it is better to use the less
resource-intensive mechanisms like "ip4" and "ip6" over "a" or "a"
over "mx".</p>
</div>
<div class="paragraph">
<p>Publishing SPF records for domains that send no mail is a well-established
best practice.
The record for a domain that sends no mail is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>www.example.com.   IN TXT  "v=spf1 -all"</pre>
</div>
</div>
<div class="paragraph">
<p>Publishing SPF records for individual hosts is also best practice.
The host name is generally the identity used in the 5321.HELO/.EHLO
command.
In the case of messages with a null 5321.MailFrom, this is used as the
domain for 5321.MailFrom SPF checks, in addition to being used in
5321.HELO/.EHLO-based SPF checks.
The standard SPF record for an individual host that is involved in
mail processing is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>relay.example.com.   IN TXT  "v=spf1 a -all"</pre>
</div>
</div>
<div class="paragraph">
<p>Validating correct deployment is difficult.  [RFC6652] describes one
mechanism for soliciting feedback on SPF failures.
Another suggestion can be found in Appendix C.</p>
</div>
<div class="paragraph">
<p>Regardless of the method used, understanding the ADMD&#8217;s outbound mail
architecture is essential to effective deployment.</p>
</div>
</div>
<div class="sect3">
<h4 id="_bounces"><a class="anchor" href="#_bounces"></a>10.1.3. Bounces</h4>
<div class="paragraph">
<p>In this case, the only entity available for performing an SPF check is
the "HELO" identity defined in Section 1.1.4.
SPF functionality is enhanced by administrators ensuring this identity
is set correctly and has an appropriate SPF record.
It is normal to have the "HELO" identity set to the host name instead
of the domain.
Zone file generation for significant numbers of hosts can be
consolidated using the "redirect" modifier and scripted for initial
deployment.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_receivers"><a class="anchor" href="#_receivers"></a>10.2. Receivers</h3>
<div class="paragraph">
<p>There is no comprehensive normative requirement for specific handling
of a message based on SPF results.
The information presented in Section 8 and in Appendix G is offered
for receiver consideration when forming local handling policies.</p>
</div>
<div class="paragraph">
<p>The primary considerations are that SPF might return "pass" for mail
that is ultimately harmful (e.g., spammers that arrange for SPF to
pass using disposable domain names, or virus or spam outbreaks from
within trusted sources), and might also return "fail" for mail that
is ultimately legitimate (e.g., legitimate mail that has traversed a
mail alias).
It is important to take both of these cases under consideration when
establishing local handling policy.</p>
</div>
</div>
<div class="sect2">
<h3 id="_mediator"><a class="anchor" href="#_mediator"></a>10.3. Mediator</h3>
<div class="paragraph">
<p>A mediator takes 'delivery&#8217; of a message and posts a 'submission&#8217; of a
new message.
The mediator can make the newly posted message be as similar to or as
different from the original message as they wish.
Examples include mailing lists (see Section 5.3 of [RFC5598]) and
ReSenders (Section 5.2 of [RFC5598]).
This is discussed in [RFC5321], Section 3.9.
For the operation of SPF, the essential concern is the email address
in the 5321.MailFrom command for the new message.</p>
</div>
<div class="paragraph">
<p>Because SPF evaluation is based on the IP address of the "last"
sending SMTP server, the address of the mediator will be used, rather
than the address of the SMTP server that sent the message to the
mediator.
Some mediators retain the email address from the original message,
while some use a new address.</p>
</div>
<div class="paragraph">
<p>If the address is the same as for the original message, and the
original message had an associated SPF record, then the SPF evaluation
will fail unless mitigations such as those described in Appendix D are
used.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_security_considerations"><a class="anchor" href="#_security_considerations"></a>11. Security Considerations</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_processing_limits"><a class="anchor" href="#_processing_limits"></a>11.1. Processing Limits</h3>
<div class="paragraph">
<p>The processing limits outlined in Section 4.6.4 are designed to
prevent attacks such as the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A malicious party could create an SPF record with many references
to a victim&#8217;s domain and send many emails to different SPF
verifiers; those SPF verifiers would then create a DoS attack.
In effect, the SPF verifiers are being used to amplify the
attacker&#8217;s bandwidth by using fewer octets in the SMTP session than
are used by the DNS queries.
Using SPF verifiers also allows the attacker to hide the true
source of the attack.
This potential attack is based on large volumes of mail being
transmitted.</p>
</li>
<li>
<p>Whereas implementations of check_host() are supposed to limit the
number of DNS lookups, malicious domains could publish records
that exceed these limits in an attempt to waste computation effort
at their targets when they send them mail.
Malicious domains could also design SPF records that cause
particular implementations to use excessive memory or CPU or to
trigger bugs.
If a receiver is configured to accept mail with an SPF result of
"temperror", such an attack might result in mail that would
otherwise have been rejected due to an SPF "fail" result being
accepted.
This potential attack is based on specially crafted SPF records
being used to exhaust DNS resources of the victim.</p>
</li>
<li>
<p>Malicious parties could send a large volume of mail purporting to
come from the intended target to a wide variety of legitimate mail
hosts.
These legitimate machines would then present a DNS load on the
target as they fetched the relevant records.</p>
</li>
<li>
<p>Malicious parties could, in theory, use SPF records as a vehicle
for DNS lookup amplification for a DoS attack.
In this scenario, the attacker publishes an SPF record in its own
DNS that uses "a" and "mx" mechanisms directed toward the intended
victim, e.g., "a:example.com a:foo.example.com a:bar.example.com</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>and then distributes mail with a MAIL FROM value including its
own domain in large volume to a wide variety of destinations.
Any such destination operating an SPF verifier will begin querying
all of the names associated with the "a" mechanisms in that record.
The names used in the record needn&#8217;t exist for the attack to be
effective.
Operational experience since the publication of [RFC4408] suggests
that mitigation of this class of attack can be accomplished with
minimal impact on the deployed base by having the verifier abort
processing and return "permerror" (Section 2.6.7) as soon as more
than two "void lookups" have been encountered (defined in Section
4.6.4).</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Of these, the case of a third party referenced in the SPF record is
the easiest for a DoS attack to effectively exploit.
As a result, limits that might seem reasonable for an individual mail
server can still allow an unreasonable amount of bandwidth
amplification.
Therefore, the processing limits need to be quite low.</p>
</div>
</div>
<div class="sect2">
<h3 id="_spf_authorized_email_may_contain_other_false_identities"><a class="anchor" href="#_spf_authorized_email_may_contain_other_false_identities"></a>11.2. SPF-Authorized Email May Contain Other False Identities</h3>
<div class="paragraph">
<p>The "MAIL FROM" and "HELO" identity authorizations do not provide
assurance about the authorization/authenticity of other identities
used in the message.
It is entirely possible for a malicious sender to inject a message
using his own domain in the identities used by SPF and have that
domain&#8217;s SPF record authorize the sending host, and yet the message
can easily list other identities in its header.
Unless the user or the MUA takes care to note that the authorized
identity does not match the other more commonly presented identities
(such as the From: header field), the user might be lulled into a
false sense of security.</p>
</div>
</div>
<div class="sect2">
<h3 id="_spoofed_dns_and_ip_data"><a class="anchor" href="#_spoofed_dns_and_ip_data"></a>11.3. Spoofed DNS and IP Data</h3>
<div class="paragraph">
<p>There are two aspects of this protocol that malicious parties could
exploit to undermine the validity of the check_host() function:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The evaluation of check_host() relies heavily on DNS.
A malicious attacker could attack the DNS infrastructure and cause
check_host() to see spoofed DNS data, and then return incorrect
results.
This could include returning "pass" for an &lt;ip&gt; value where the
actual domain&#8217;s record would evaluate to "fail".
See [RFC3833] for a description of DNS weaknesses, and see
[RFC4033] for a countermeasure.</p>
</li>
<li>
<p>The client IP address, &lt;ip&gt;, is assumed to be correct.
In a modern, correctly configured system, the risk of this not
being true is nil.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_cross_user_forgery"><a class="anchor" href="#_cross_user_forgery"></a>11.4. Cross-User Forgery</h3>
<div class="paragraph">
<p>By definition, SPF policies just map domain names to sets of
authorized MTAs, not whole email addresses to sets of authorized
users.
Although the "l" macro (Section 7) provides a limited way to define
individual sets of authorized MTAs for specific email addresses, it is
generally impossible to verify, through SPF, the use of specific email
addresses by individual users of the same MTA.</p>
</div>
<div class="paragraph">
<p>It is up to mail services and their MTAs to directly prevent
cross-user forgery: based on SMTP AUTH ([RFC4954]), users have to be
restricted to using only those email addresses that are actually under
their control (see Section 6.1 of [RFC6409]).
Another means to verify the identity of individual users is message
cryptography, such as Pretty Good Privacy (PGP) ([RFC4880]) or S/MIME
([RFC5751]).</p>
</div>
</div>
<div class="sect2">
<h3 id="_untrusted_information_sources"><a class="anchor" href="#_untrusted_information_sources"></a>11.5. Untrusted Information Sources</h3>
<div class="paragraph">
<p>An SPF-compliant receiver gathers information from the SMTP commands
it receives and from the published DNS records of the sending domain
holder (e.g., "HELO" domain name, the "MAIL FROM" address from the
envelope, and SPF DNS records published by the domain holder).
These parameters are not validated in the SMTP process.</p>
</div>
<div class="paragraph">
<p>All of these pieces of information are generated by actors outside of
the authority of the receiver, and thus are not guaranteed to be
accurate or legitimate.</p>
</div>
<div class="sect3">
<h4 id="_recorded_results"><a class="anchor" href="#_recorded_results"></a>11.5.1. Recorded Results</h4>
<div class="paragraph">
<p>This information, passed to the receiver in the Received-SPF: or
Authentication-Results: trace fields, can be returned to the client
MTA as an SMTP rejection message.
If such an SMTP rejection message is generated, the information from
the trace fields has to be checked for such problems as invalid
characters and excessively long lines.</p>
</div>
</div>
<div class="sect3">
<h4 id="_external_explanations"><a class="anchor" href="#_external_explanations"></a>11.5.2. External Explanations</h4>
<div class="paragraph">
<p>When the authorization check fails, an explanation string could be
included in the reject response.
Both the sender and the rejecting receiver need to be aware that the
explanation was determined by the publisher of the SPF record checked
and, in general, not the receiver.
The explanation can contain malicious URLs, or it might be offensive
or misleading.</p>
</div>
<div class="paragraph">
<p>Explanations returned to sender domains due to "exp" modifiers
(Section 6.2) were generated by the sender policy published by the
domain holders themselves.
As long as messages are only returned with non-delivery notifications
([RFC3464]) to domains publishing the explanation strings from their
own DNS SPF records, the only affected parties are the original
publishers of the domain&#8217;s SPF records.</p>
</div>
<div class="paragraph">
<p>In practice, such non-delivery notifications can be misdirected, such
as when an MTA accepts an email and only later generates the
notification to a forged address, or when an email forwarder does not
direct the bounce back to the original sender.</p>
</div>
</div>
<div class="sect3">
<h4 id="_macro_expansion"><a class="anchor" href="#_macro_expansion"></a>11.5.3. Macro Expansion</h4>
<div class="paragraph">
<p>Macros (Section 7) allow senders to inject arbitrary text (any
non-null [US-ASCII] character) into receiver DNS queries.
It is necessary to be prepared for hostile or unexpected content.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_privacy_exposure"><a class="anchor" href="#_privacy_exposure"></a>11.6. Privacy Exposure</h3>
<div class="paragraph">
<p>Checking SPF records causes DNS queries to be sent to the domain
owner.
These DNS queries, especially if they are caused by the "exists"
mechanism, can contain information about who is sending email and
likely to which MTA the email is being sent.
This can introduce some privacy concerns, which are more or less of an
issue depending on local laws and the relationship between the ADMD
and the person sending the email.</p>
</div>
</div>
<div class="sect2">
<h3 id="_delivering_mail_producing_a_fail_result"><a class="anchor" href="#_delivering_mail_producing_a_fail_result"></a>11.7. Delivering Mail Producing a "Fail" Result</h3>
<div class="paragraph">
<p>Operators that choose to deliver mail for which SPF produces a "fail"
result need to understand that they are admitting content that is
explicitly not authorized by the purported sender.
While there are known failure modes that can be considered "false
negatives", the distinct choice to admit those messages increases
end-user exposure to likely harm.
This is especially true for domains belonging to known good actors
that are typically well-behaved; unauthorized mail from those sources
might well be subjected to much higher skepticism and content
analysis.</p>
</div>
<div class="paragraph">
<p>SPF does not, however, include the capacity to distinguish good actors
from bad ones, nor does it handle the concept of known actors versus
unknown ones.
Those notions are out of scope for this specification.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-11-08 18:25:32 +0700
</div>
</div>
			</div>
			
		</div>
		

		<div class="footer">
			Powered by <a
				href="https://git.sr.ht/shulhan/ciigo"
			>
				ciigo
			</a>
		</div>
	</body>
</html>